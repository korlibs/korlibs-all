// @WARNING: File AUTOGENERATED by `korlibs/src/test/kotlin/KmemGenerator.kt` @ korlibs/kmem do not modify manually!
// @TODO: USELESS_CAST is required since it requires a cast to work, but IDE says that that cast is not necessary
@file:Suppress("NOTHING_TO_INLINE", "EXTENSION_SHADOWED_BY_MEMBER", "RedundantUnitReturnType", "FunctionName", "USELESS_CAST")
package com.soywiz.kmem

actual class MemBuffer(val data: ByteArray)
actual fun MemBufferAlloc(size: Int): MemBuffer = MemBuffer(ByteArray(size))
actual fun MemBufferWrap(array: ByteArray): MemBuffer = MemBuffer(array)
actual inline val MemBuffer.size: Int get() = data.size

actual fun MemBuffer._sliceInt8Buffer(offset: Int, size: Int): Int8Buffer = Int8Buffer(this, offset * 1, size)
actual fun MemBuffer._sliceInt16Buffer(offset: Int, size: Int): Int16Buffer = Int16Buffer(this, offset * 2, size)
actual fun MemBuffer._sliceInt32Buffer(offset: Int, size: Int): Int32Buffer = Int32Buffer(this, offset * 4, size)
actual fun MemBuffer._sliceFloat32Buffer(offset: Int, size: Int): Float32Buffer = Float32Buffer(this, offset * 4, size)
actual fun MemBuffer._sliceFloat64Buffer(offset: Int, size: Int): Float64Buffer = Float64Buffer(this, offset * 8, size)

actual typealias DataBuffer = MemBuffer
actual fun MemBuffer.getData(): DataBuffer = this

actual fun DataBuffer.getByte(index: Int): Byte = data.get(index)
actual fun DataBuffer.getShort(index: Int): Short = data.shortAt(index)
actual fun DataBuffer.getInt(index: Int): Int = data.intAt(index)
actual fun DataBuffer.getFloat(index: Int): Float = data.floatAt(index)
actual fun DataBuffer.getDouble(index: Int): Double = data.doubleAt(index)

actual fun DataBuffer.setByte(index: Int, value: Byte): Unit = data.set(index, value)
actual fun DataBuffer.setShort(index: Int, value: Short): Unit = data.setShortAt(index, value)
actual fun DataBuffer.setInt(index: Int, value: Int): Unit = data.setIntAt(index, value)
actual fun DataBuffer.setFloat(index: Int, value: Float): Unit = data.setFloatAt(index, value)
actual fun DataBuffer.setDouble(index: Int, value: Double): Unit = data.setDoubleAt(index, value)

////////////////////

actual class Int8Buffer(val mbuffer: MemBuffer, val byteOffset: Int, val size: Int) {
	companion object {
		const val SIZE = 1
	}
	val MOFFSET = byteOffset / SIZE
	val MSIZE = size / SIZE
	fun getByteIndex(index: Int) = byteOffset + index * SIZE
}
actual val Int8Buffer.mem: MemBuffer get() = mbuffer
actual val Int8Buffer.offset: Int get() = MOFFSET
actual val Int8Buffer.size: Int get() = MSIZE
actual operator fun Int8Buffer.get(index: Int): Byte = mbuffer.getByte(getByteIndex(index))
actual operator fun Int8Buffer.set(index: Int, value: Byte): Unit = mbuffer.setByte(getByteIndex(index), value)

actual class Int16Buffer(val mbuffer: MemBuffer, val byteOffset: Int, val size: Int) {
	companion object {
		const val SIZE = 2
	}
	val MOFFSET = byteOffset / SIZE
	val MSIZE = size / SIZE
	fun getByteIndex(index: Int) = byteOffset + index * SIZE
}
actual val Int16Buffer.mem: MemBuffer get() = mbuffer
actual val Int16Buffer.offset: Int get() = MOFFSET
actual val Int16Buffer.size: Int get() = MSIZE
actual operator fun Int16Buffer.get(index: Int): Short = mbuffer.getShort(getByteIndex(index))
actual operator fun Int16Buffer.set(index: Int, value: Short): Unit = mbuffer.setShort(getByteIndex(index), value)

actual class Int32Buffer(val mbuffer: MemBuffer, val byteOffset: Int, val size: Int) {
	companion object {
		const val SIZE = 4
	}
	val MOFFSET = byteOffset / SIZE
	val MSIZE = size / SIZE
	fun getByteIndex(index: Int) = byteOffset + index * SIZE
}
actual val Int32Buffer.mem: MemBuffer get() = mbuffer
actual val Int32Buffer.offset: Int get() = MOFFSET
actual val Int32Buffer.size: Int get() = MSIZE
actual operator fun Int32Buffer.get(index: Int): Int = mbuffer.getInt(getByteIndex(index))
actual operator fun Int32Buffer.set(index: Int, value: Int): Unit = mbuffer.setInt(getByteIndex(index), value)

actual class Float32Buffer(val mbuffer: MemBuffer, val byteOffset: Int, val size: Int) {
	companion object {
		const val SIZE = 4
	}
	val MOFFSET = byteOffset / SIZE
	val MSIZE = size / SIZE
	fun getByteIndex(index: Int) = byteOffset + index * SIZE
}
actual val Float32Buffer.mem: MemBuffer get() = mbuffer
actual val Float32Buffer.offset: Int get() = MOFFSET
actual val Float32Buffer.size: Int get() = MSIZE
actual operator fun Float32Buffer.get(index: Int): Float = mbuffer.getFloat(getByteIndex(index))
actual operator fun Float32Buffer.set(index: Int, value: Float): Unit = mbuffer.setFloat(getByteIndex(index), value)

actual class Float64Buffer(val mbuffer: MemBuffer, val byteOffset: Int, val size: Int) {
	companion object {
		const val SIZE = 8
	}
	val MOFFSET = byteOffset / SIZE
	val MSIZE = size / SIZE
	fun getByteIndex(index: Int) = byteOffset + index * SIZE
}
actual val Float64Buffer.mem: MemBuffer get() = mbuffer
actual val Float64Buffer.offset: Int get() = MOFFSET
actual val Float64Buffer.size: Int get() = MSIZE
actual operator fun Float64Buffer.get(index: Int): Double = mbuffer.getDouble(getByteIndex(index))
actual operator fun Float64Buffer.set(index: Int, value: Double): Unit = mbuffer.setDouble(getByteIndex(index), value)

////////////////////

actual fun <T> arraycopy(src: Array<T>, srcPos: Int, dst: Array<T>, dstPos: Int, size: Int): Unit {
	if (src === dst && dstPos > srcPos) { // overlapping
		var n = size
		while (--n >= 0) dst[dstPos + n] = src[srcPos + n]
	} else {
		for (n in 0 until size) dst[dstPos + n] = src[srcPos + n]
	}
}

actual fun arraycopy(src: BooleanArray, srcPos: Int, dst: BooleanArray, dstPos: Int, size: Int): Unit {
	if (src === dst && dstPos > srcPos) { // overlapping
		var n = size
		while (--n >= 0) dst[dstPos + n] = src[srcPos + n]
	} else {
		for (n in 0 until size) dst[dstPos + n] = src[srcPos + n]
	}
}
actual fun arraycopy(src: LongArray, srcPos: Int, dst: LongArray, dstPos: Int, size: Int): Unit {
	if (src === dst && dstPos > srcPos) { // overlapping
		var n = size
		while (--n >= 0) dst[dstPos + n] = src[srcPos + n]
	} else {
		for (n in 0 until size) dst[dstPos + n] = src[srcPos + n]
	}
}
actual fun arraycopy(src: ByteArray, srcPos: Int, dst: ByteArray, dstPos: Int, size: Int): Unit {
	if (src === dst && dstPos > srcPos) { // overlapping
		var n = size
		while (--n >= 0) dst[dstPos + n] = src[srcPos + n]
	} else {
		for (n in 0 until size) dst[dstPos + n] = src[srcPos + n]
	}
}
actual fun arraycopy(src: ShortArray, srcPos: Int, dst: ShortArray, dstPos: Int, size: Int): Unit {
	if (src === dst && dstPos > srcPos) { // overlapping
		var n = size
		while (--n >= 0) dst[dstPos + n] = src[srcPos + n]
	} else {
		for (n in 0 until size) dst[dstPos + n] = src[srcPos + n]
	}
}
actual fun arraycopy(src: IntArray, srcPos: Int, dst: IntArray, dstPos: Int, size: Int): Unit {
	if (src === dst && dstPos > srcPos) { // overlapping
		var n = size
		while (--n >= 0) dst[dstPos + n] = src[srcPos + n]
	} else {
		for (n in 0 until size) dst[dstPos + n] = src[srcPos + n]
	}
}
actual fun arraycopy(src: FloatArray, srcPos: Int, dst: FloatArray, dstPos: Int, size: Int): Unit {
	if (src === dst && dstPos > srcPos) { // overlapping
		var n = size
		while (--n >= 0) dst[dstPos + n] = src[srcPos + n]
	} else {
		for (n in 0 until size) dst[dstPos + n] = src[srcPos + n]
	}
}
actual fun arraycopy(src: DoubleArray, srcPos: Int, dst: DoubleArray, dstPos: Int, size: Int): Unit {
	if (src === dst && dstPos > srcPos) { // overlapping
		var n = size
		while (--n >= 0) dst[dstPos + n] = src[srcPos + n]
	} else {
		for (n in 0 until size) dst[dstPos + n] = src[srcPos + n]
	}
}

actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = arraycopy(src.data, srcPos, dst.data, dstPos, size)
actual fun arraycopy(src: ByteArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = arraycopy(src, srcPos, dst.data, dstPos, size)
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: ByteArray, dstPos: Int, size: Int): Unit = arraycopy(src.data, srcPos, dst, dstPos, size)

actual fun arraycopy(src: ShortArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = run { for (n in 0 until size) dst.setShort((dstPos + n) * 2, src[srcPos + n]) }
actual fun arraycopy(src: IntArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = run { for (n in 0 until size) dst.setInt((dstPos + n) * 4, src[srcPos + n]) }
actual fun arraycopy(src: FloatArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = run { for (n in 0 until size) dst.setFloat((dstPos + n) * 4, src[srcPos + n]) }
actual fun arraycopy(src: DoubleArray, srcPos: Int, dst: MemBuffer, dstPos: Int, size: Int): Unit = run { for (n in 0 until size) dst.setDouble((dstPos + n) * 8, src[srcPos + n]) }

actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: ShortArray, dstPos: Int, size: Int): Unit = run { for (n in 0 until size) dst[dstPos + n] = src.getShort((srcPos + n) * 2) }
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: IntArray, dstPos: Int, size: Int): Unit = run { for (n in 0 until size) dst[dstPos + n] = src.getInt((srcPos + n) * 4) }
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: FloatArray, dstPos: Int, size: Int): Unit = run { for (n in 0 until size) dst[dstPos + n] = src.getFloat((srcPos + n) * 4) }
actual fun arraycopy(src: MemBuffer, srcPos: Int, dst: DoubleArray, dstPos: Int, size: Int): Unit = run { for (n in 0 until size) dst[dstPos + n] = src.getDouble((srcPos + n) * 8) }

@PublishedApi internal actual fun <T> _fill(array: Array<T>, value: T, start: Int, end: Int): Unit = run { for (n in start until end) array[n] = value  }
@PublishedApi internal actual fun  _fill(array: BooleanArray, value: Boolean, start: Int, end: Int): Unit = run { for (n in start until end) array[n] = value  }
@PublishedApi internal actual fun  _fill(array: LongArray, value: Long, start: Int, end: Int): Unit = run { for (n in start until end) array[n] = value  }
@PublishedApi internal actual fun _fill(array: ByteArray, value: Byte, start: Int, end: Int): Unit = run { for (n in start until end) array[n] = value  }
@PublishedApi internal actual fun _fill(array: ShortArray, value: Short, start: Int, end: Int): Unit = run { for (n in start until end) array[n] = value  }
@PublishedApi internal actual fun _fill(array: IntArray, value: Int, start: Int, end: Int): Unit = run { for (n in start until end) array[n] = value  }
@PublishedApi internal actual fun _fill(array: FloatArray, value: Float, start: Int, end: Int): Unit = run { for (n in start until end) array[n] = value  }
@PublishedApi internal actual fun _fill(array: DoubleArray, value: Double, start: Int, end: Int): Unit = run { for (n in start until end) array[n] = value  }
